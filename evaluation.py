"""
evaluation.py

This module implements the Evaluation class for the MFS©\VRPD project.
It takes the final solution produced by Trainer (either from MILPModel or ALNSModel)
and the corresponding instance data, computes key performance metrics, summarizes
them in a tabular format, and provides visualization tools for further analysis.

Metrics computed include:
    - Overall objective cost (Z_total)
    - Breakdown of cost components: truck_cost and drone_cost
    - Computation runtime
    - Service composition: number of truck-served customers (n_t),
      number of drone-served customers (n_d), and number of drone sub©\routes (n_s)
    - Cost per truck customer (u_c_t) and cost per drone customer (u_c_d)
    - Improvement percentage over a baseline truck-only solution
    - Gap percentage if a lower bound is available

The module uses configuration parameters defined in config.py.
"""

import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Any, Dict, Optional

# Import global configuration from config.py.
from config import CONFIG
# Import InstanceData datatype for type hinting.
# Note: Avoid circular imports; InstanceData is defined in dataset_loader.py.
try:
    from dataset_loader import InstanceData
except ImportError:
    # In case the module is not available, we define a dummy type.
    InstanceData = Any


class Evaluation:
    """
    Evaluation class for computing and visualizing performance metrics of the MFS©\VRPD solution.
    
    Attributes:
        solution (Dict[str, Any]): The final solution produced by the Trainer.
            Expected keys include:
                - "objective" or "cost": Total transportation cost (Z_total)
                - "truck_routes": List of truck routes (each route is a list of node indices)
                - "drone_subroutes" or "drone_routes": List of drone subroutes
                - "runtime": Computation time in seconds
                - Optionally, "lower_bound": Lower bound cost (for gap calculation)
        instance (InstanceData): The instance data including network matrices,
            customer demands, and other problem details.
    """
    
    def __init__(self, solution: Dict[str, Any], instance: InstanceData) -> None:
        """
        Initialize an Evaluation object with the provided solution and instance data.
        
        Args:
            solution (Dict[str, Any]): The final solution dictionary.
            instance (InstanceData): The instance data generated by DatasetLoader.
        """
        self.solution = solution
        self.instance = instance
        
        # Retrieve fleet and cost parameters from the configuration.
        self.truck_cost_per_km: float = float(CONFIG.cost_parameters.truck_cost)
        self.drone_cost_per_km: float = float(CONFIG.cost_parameters.drone_cost)
        self.truck_distance_matrix: np.ndarray = self.instance.distance_matrix_truck
        self.drone_distance_matrix: np.ndarray = self.instance.distance_matrix_drone

    def evaluate(self) -> Dict[str, Optional[float]]:
        """
        Evaluate the final solution and compute performance metrics.
        
        Returns:
            Dict[str, Optional[float]]: A dictionary containing computed metrics.
                Keys:
                    "objective_cost"         : Total solution cost (Z_total)
                    "truck_cost"             : Total cost incurred by truck routes
                    "drone_cost"             : Total cost incurred by drone routes
                    "runtime"                : Computation time in seconds
                    "num_truck_customers"    : Total number of customers served by trucks (n_t)
                    "num_drone_customers"    : Total number of customers served by drones (n_d)
                    "num_drone_subroutes"    : Number of drone sub©\routes (n_s)
                    "cost_per_truck_customer": u_c_t; cost per truck-served customer
                    "cost_per_drone_customer": u_c_d; cost per drone-served customer
                    "improvement_percentage" : Improvement (%) over truck-only baseline
                    "gap_percentage"         : Gap (%) if a lower bound is available; otherwise None.
        """
        # 1. Extract overall solution cost (Z_total)
        if "objective" in self.solution:
            Z_total: float = float(self.solution["objective"])
        elif "cost" in self.solution:
            Z_total = float(self.solution["cost"])
        else:
            raise ValueError("Solution must contain an 'objective' or 'cost' field for total cost.")
        
        # 2. Compute cost breakdown for truck routes.
        truck_cost: float = 0.0
        truck_routes = self.solution.get("truck_routes", [])
        num_truck_customers: int = 0
        for route in truck_routes:
            if not route or len(route) < 2:
                continue
            # Exclude depot (first and last nodes) for customer count.
            customers_in_route = route[1:-1]
            num_truck_customers += len(customers_in_route)
            # Sum cost along the route.
            for i in range(len(route) - 1):
                from_node = route[i]
                to_node = route[i + 1]
                truck_cost += self.truck_cost_per_km * self.truck_distance_matrix[from_node, to_node]
        
        # 3. Compute cost breakdown for drone routes.
        drone_cost: float = 0.0
        num_drone_customers: int = 0
        num_drone_subroutes: int = 0
        # Check whether solution has "drone_subroutes" (as typically output by ALNSModel).
        if "drone_subroutes" in self.solution:
            drone_subroutes = self.solution.get("drone_subroutes", [])
            num_drone_subroutes = len(drone_subroutes)
            for sub in drone_subroutes:
                launch: int = sub.get("launch")
                docking: int = sub.get("docking")
                visited: list = sub.get("visited", [])
                num_drone_customers += len(visited)
                
                if visited:
                    # Cost from launch to first visited.
                    cost_sub = self.drone_cost_per_km * self.drone_distance_matrix[launch, visited[0]]
                    # Cost between consecutive visited nodes.
                    for idx in range(len(visited) - 1):
                        cost_sub += self.drone_cost_per_km * self.drone_distance_matrix[visited[idx], visited[idx + 1]]
                    # Cost from last visited to docking.
                    cost_sub += self.drone_cost_per_km * self.drone_distance_matrix[visited[-1], docking]
                    drone_cost += cost_sub
        # Else if solution uses "drone_routes" key (e.g., MILPModel solution)
        elif "drone_routes" in self.solution:
            drone_routes = self.solution.get("drone_routes", [])
            # Count only routes that are nontrivial (length>=2)
            for route in drone_routes:
                if not route or len(route) < 2:
                    continue
                num_drone_subroutes += 1
                # Exclude depot nodes for customer count.
                customers_in_route = route[1:-1]
                num_drone_customers += len(customers_in_route)
                # Sum cost along the drone route.
                for i in range(len(route) - 1):
                    from_node = route[i]
                    to_node = route[i + 1]
                    drone_cost += self.drone_cost_per_km * self.drone_distance_matrix[from_node, to_node]
        else:
            # No drone route information available.
            num_drone_subroutes = 0
            num_drone_customers = 0
            drone_cost = 0.0
        
        # 4. Retrieve runtime from solution.
        runtime: float = float(self.solution.get("runtime", 0.0))
        
        # 5. Compute cost per customer.
        cost_per_truck_customer: float = truck_cost / num_truck_customers if num_truck_customers > 0 else 0.0
        cost_per_drone_customer: float = drone_cost / num_drone_customers if num_drone_customers > 0 else 0.0
        
        # 6. Compute baseline truck-only cost.
        # If instance has an attribute 'truck_only_cost', use it; otherwise, compute a naive baseline.
        if hasattr(self.instance, "truck_only_cost"):
            baseline_truck_only_cost = float(getattr(self.instance, "truck_only_cost"))
        else:
            # Compute baseline cost using a simple truck-only route that visits customers in increasing order.
            # Route: [0, 1, 2, ..., num_customers, duplicate depot]
            route_baseline = [0] + list(range(1, self.instance.num_customers + 1)) + [self.instance.num_nodes - 1]
            baseline_truck_only_cost: float = 0.0
            for i in range(len(route_baseline) - 1):
                from_node = route_baseline[i]
                to_node = route_baseline[i + 1]
                baseline_truck_only_cost += self.truck_cost_per_km * self.truck_distance_matrix[from_node, to_node]
        
        # 7. Compute improvement percentage.
        improvement_percentage: float = 100.0 * (baseline_truck_only_cost - Z_total) / baseline_truck_only_cost
        
        # 8. Compute gap percentage if lower bound is provided.
        lower_bound: Optional[float] = self.solution.get("lower_bound", None)
        gap_percentage: Optional[float] = None
        if lower_bound is not None and lower_bound > 0:
            gap_percentage = 100.0 * (Z_total - lower_bound) / lower_bound
        
        # 9. Assemble all computed metrics into a dictionary.
        metrics: Dict[str, Optional[float]] = {
            "objective_cost": Z_total,
            "truck_cost": truck_cost,
            "drone_cost": drone_cost,
            "runtime": runtime,
            "num_truck_customers": float(num_truck_customers),
            "num_drone_customers": float(num_drone_customers),
            "num_drone_subroutes": float(num_drone_subroutes),
            "cost_per_truck_customer": cost_per_truck_customer,
            "cost_per_drone_customer": cost_per_drone_customer,
            "improvement_percentage": improvement_percentage,
            "gap_percentage": gap_percentage
        }
        
        return metrics

    def visualize(self, metrics: Dict[str, Optional[float]]) -> None:
        """
        Visualize key performance metrics using matplotlib.
        
        Generates:
            - A bar chart comparing truck cost vs. drone cost.
            - A text summary displayed on the plot with overall metrics.
        
        Args:
            metrics (Dict[str, Optional[float]]): The metrics dictionary produced by evaluate().
        """
        # Bar chart for cost breakdown
        cost_categories = ['Truck Cost', 'Drone Cost']
        cost_values = [metrics.get("truck_cost", 0.0), metrics.get("drone_cost", 0.0)]
        
        plt.figure(figsize=(8, 6))
        bars = plt.bar(cost_categories, cost_values, color=['blue', 'green'])
        plt.xlabel("Cost Category")
        plt.ylabel("Cost (Currency Units)")
        plt.title("Cost Breakdown: Truck vs. Drone")
        
        # Annotate the bars with values
        for bar in bars:
            height = bar.get_height()
            plt.annotate(f'{height:.2f}',
                         xy=(bar.get_x() + bar.get_width() / 2, height),
                         xytext=(0, 3),
                         textcoords="offset points",
                         ha='center', va='bottom')
        
        # Summary text box with additional metrics.
        summary_text = (
            f"Objective Cost: {metrics.get('objective_cost', 0.0):.2f}\n"
            f"Runtime: {metrics.get('runtime', 0.0):.2f} s\n"
            f"Truck Customers: {int(metrics.get('num_truck_customers', 0))}\n"
            f"Drone Customers: {int(metrics.get('num_drone_customers', 0))}\n"
            f"Drone Subroutes: {int(metrics.get('num_drone_subroutes', 0))}\n"
            f"Improvement: {metrics.get('improvement_percentage', 0.0):.2f}%"
        )
        plt.gcf().text(0.65, 0.5, summary_text, fontsize=10, bbox=dict(facecolor='white', alpha=0.5))
        
        plt.tight_layout()
        plt.show()

    def generate_summary_table(self, metrics: Dict[str, Optional[float]]) -> pd.DataFrame:
        """
        Generate a summary table (pandas DataFrame) of the computed metrics.
        
        Returns:
            pd.DataFrame: A DataFrame with a single row summarizing the key metrics.
        """
        data = {
            "Objective Cost": [metrics.get("objective_cost", None)],
            "Truck Cost": [metrics.get("truck_cost", None)],
            "Drone Cost": [metrics.get("drone_cost", None)],
            "Runtime (s)": [metrics.get("runtime", None)],
            "# Truck Customers": [int(metrics.get("num_truck_customers", 0))],
            "# Drone Customers": [int(metrics.get("num_drone_customers", 0))],
            "# Drone Subroutes": [int(metrics.get("num_drone_subroutes", 0))],
            "Cost per Truck Customer": [metrics.get("cost_per_truck_customer", None)],
            "Cost per Drone Customer": [metrics.get("cost_per_drone_customer", None)],
            "Improvement (%)": [metrics.get("improvement_percentage", None)],
            "Gap (%)": [metrics.get("gap_percentage", None)]
        }
        df = pd.DataFrame(data)
        return df


# For testing and demonstration purposes, run evaluation if this module is executed directly.
if __name__ == "__main__":
    # Dummy solution and instance for demonstration.
    # In a full project, these will be obtained from Trainer and DatasetLoader.
    
    # Create a dummy instance. Here we simulate minimal required attributes.
    class DummyInstance:
        def __init__(self):
            self.num_customers = 10
            self.num_nodes = self.num_customers + 2
            # Generate dummy distance matrices as identity scaled matrices.
            self.distance_matrix_truck = np.ones((self.num_nodes, self.num_nodes)) * 5.0
            self.distance_matrix_drone = np.ones((self.num_nodes, self.num_nodes)) * 3.0
            # For reproducibility, set a truck_only_cost attribute.
            # Compute a naive baseline route: 0,1,...,num_customers,dup_depot
            route = [0] + list(range(1, self.num_customers + 1)) + [self.num_nodes - 1]
            cost = 0.0
            for i in range(len(route)-1):
                cost += CONFIG.cost_parameters.truck_cost * self.distance_matrix_truck[route[i], route[i+1]]
            self.truck_only_cost = cost

    # Create a dummy solution with truck_routes and drone_subroutes.
    dummy_solution = {
        "objective": 150.0,
        "truck_routes": [
            [0, 2, 5, 11],  # route for truck 0 (0: depot, 11: duplicate depot)
            [0, 1, 3, 4, 11]  # route for truck 1
        ],
        "drone_subroutes": [
            {"launch": 2, "visited": [6, 7], "docking": 5},
            {"launch": 3, "visited": [8], "docking": 4}
        ],
        "runtime": 25.0,
        "lower_bound": 140.0
    }
    
    dummy_instance = DummyInstance()
    
    evaluator = Evaluation(solution=dummy_solution, instance=dummy_instance)
    metrics = evaluator.evaluate()
    summary_df = evaluator.generate_summary_table(metrics)
    
    print("Evaluation Metrics Summary:")
    print(summary_df)
    
    # Visualize the evaluation metrics.
    evaluator.visualize(metrics)
