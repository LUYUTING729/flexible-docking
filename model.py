"""model.py
This module implements the MILPModel and ALNSModel classes for the MFS©\VRPD project.
It uses the gurobipy solver for the MILP model (small instances) and an Adaptive 
Large Neighborhood Search (ALNS) metaheuristic for medium/large instances.

The MILPModel builds a complete MILP formulation that includes decision variables 
for truck and drone routing, synchronization (timing and endurance), and loading.
The ALNSModel provides an initial solution generator (via a two©\phase nearest neighbor 
heuristic and conversion procedure) and an iterative improvement loop that applies 
destroy and repair operators with adaptive weight updates and simulated annealing©\based 
acceptance criteria.
"""

import math
import random
import copy
from typing import Any, Dict, List, Tuple

import numpy as np
import gurobipy as gp
from gurobipy import GRB

# Import configuration from config.py
from config import CONFIG


# ------------------------- MILPModel Class -------------------------
class MILPModel:
    """MILPModel builds and solves the MILP formulation for the MFS©\VRPD."""
    
    def __init__(self, instance: Any, config: Any) -> None:
        """
        Initialize the MILP model with instance data and configuration.
        
        Args:
            instance: The problem instance generated by DatasetLoader.
            config: The configuration object from config.py.
        """
        self.instance = instance
        self.config = config
        
        # Define set of nodes: indices 0 to num_nodes-1
        self.nodes: List[int] = list(range(self.instance.num_nodes))
        # Customer nodes: indices 1 .. num_customers
        self.customers: List[int] = list(range(1, self.instance.num_customers + 1))
        # Depot is at index 0; Duplicate depot is at index (num_nodes - 1)
        self.depot: int = 0
        self.dup_depot: int = self.instance.num_nodes - 1
        
        # For MILP, assume small instances -> fixed fleet sizes:
        self.num_trucks: int = 2  # as per design for small instances
        self.num_drones: int = 2
        
        # Define sets for trucks and drones by indices.
        self.trucks: List[int] = list(range(self.num_trucks))
        self.drones: List[int] = list(range(self.num_drones))
        
        # Retrieve parameters from config and instance
        self.Q_T: float = float(self.config.fleet.truck.capacity)
        self.Q_D: float = float(self.config.fleet.drone.capacity)
        self.L: float = float(self.config.working_hours)  # working hours (in hours)
        self.big_M: float = float(self.config.milp_parameters.big_M)
        self.truck_cost: float = float(self.config.cost_parameters.truck_cost)
        self.drone_cost: float = float(self.config.cost_parameters.drone_cost)
        # Drone endurance in hours. Fleet endurance given in minutes.
        self.drone_endurance: float = float(self.config.fleet.drone.endurance) / 60.0
        
        # Precomputed distance and time matrices:
        # Truck layer: distance and time matrices (A_T)
        self.d_T: np.ndarray = self.instance.distance_matrix_truck
        self.t_T: np.ndarray = self.instance.time_matrix_truck
        # Drone layer: distance and time matrices (A_D)
        self.d_D: np.ndarray = self.instance.distance_matrix_drone
        self.t_D: np.ndarray = self.instance.time_matrix_drone
        
        # Create a new Gurobi model.
        self.model: gp.Model = gp.Model("MFS_VRPD_MILP")
        self.model.Params.TimeLimit = self.config.milp_parameters.time_limit

        # Containers for decision variables.
        self.x_vars: Dict[Tuple[int, int, int], gp.Var] = {}  # binary: truck k travels (i,j)
        self.y_vars: Dict[Tuple[int, int, int], gp.Var] = {}  # binary: drone d flies (i,j)
        self.z_vars: Dict[Tuple[int, int, int, int], gp.Var] = {}  # linking variable
        
        self.aT_vars: Dict[Tuple[int, int], gp.Var] = {}  # truck arrival time at node i for truck k
        self.aD_vars: Dict[Tuple[int, int], gp.Var] = {}  # drone arrival time at node i for drone d
        
        # Endurance variables for drones
        self.b_minus_vars: Dict[Tuple[int, int], gp.Var] = {}  # cumulative flight time before service at node i for drone d
        self.b_plus_vars: Dict[Tuple[int, int], gp.Var] = {}   # cumulative flight time after transshipment at node i for drone d
        
        # Load variables: For trucks (delivery: F, pickup: G) and for drones (f, g)
        self.F_vars: Dict[Tuple[int, int], gp.Var] = {}
        self.G_vars: Dict[Tuple[int, int], gp.Var] = {}
        self.f_vars: Dict[Tuple[int, int], gp.Var] = {}
        self.g_vars: Dict[Tuple[int, int], gp.Var] = {}
        
    def build_model(self) -> None:
        """Builds the complete MILP model including variables, objective, and constraints."""
        # Create decision variables for each arc (i,j) and vehicle indices.
        for i in self.nodes:
            for j in self.nodes:
                if i == j:
                    continue
                # Variables for truck arcs: x[i,j,k] binary.
                for k in self.trucks:
                    self.x_vars[(i, j, k)] = self.model.addVar(vtype=GRB.BINARY,
                                                                 name=f"x_{i}_{j}_{k}")
                # Variables for drone arcs: y[i,j,d] binary.
                for d in self.drones:
                    self.y_vars[(i, j, d)] = self.model.addVar(vtype=GRB.BINARY,
                                                                 name=f"y_{i}_{j}_{d}")
                # Linking variables for synchronization: z[i,j,k,d] binary.
                for k in self.trucks:
                    for d in self.drones:
                        self.z_vars[(i, j, k, d)] = self.model.addVar(vtype=GRB.BINARY,
                                                                      name=f"z_{i}_{j}_{k}_{d}")
        self.model.update()
        
        # Timing variables for trucks and drones (continuous, non-negative).
        for i in self.nodes:
            for k in self.trucks:
                self.aT_vars[(i, k)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                          name=f"aT_{i}_{k}")
        for i in self.nodes:
            for d in self.drones:
                self.aD_vars[(i, d)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                          name=f"aD_{i}_{d}")
        self.model.update()
        
        # Endurance variables for drones: continuous, non-negative.
        for i in self.nodes:
            for d in self.drones:
                self.b_minus_vars[(i, d)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                               name=f"bMinus_{i}_{d}")
                self.b_plus_vars[(i, d)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                              name=f"bPlus_{i}_{d}")
        self.model.update()
        
        # Load variables for trucks: F (delivery load), G (pickup load).
        for i in self.nodes:
            for k in self.trucks:
                self.F_vars[(i, k)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                        name=f"F_{i}_{k}")
                self.G_vars[(i, k)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                        name=f"G_{i}_{k}")
        # Load variables for drones: f (delivery), g (pickup).
        for i in self.nodes:
            for d in self.drones:
                self.f_vars[(i, d)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                        name=f"f_{i}_{d}")
                self.g_vars[(i, d)] = self.model.addVar(lb=0.0, vtype=GRB.CONTINUOUS,
                                                        name=f"g_{i}_{d}")
        self.model.update()
        
        # ---------------------- Objective Function ----------------------
        # Objective: Minimize total transportation cost
        obj_expr = gp.LinExpr()
        # Truck cost component
        for i in self.nodes:
            for j in self.nodes:
                if i == j:
                    continue
                for k in self.trucks:
                    obj_expr.addTerms(self.truck_cost * self.d_T[i, j], self.x_vars[(i, j, k)])
        # Drone cost component
        for i in self.nodes:
            for j in self.nodes:
                if i == j:
                    continue
                for d in self.drones:
                    obj_expr.addTerms(self.drone_cost * self.d_D[i, j], self.y_vars[(i, j, d)])
        
        self.model.setObjective(obj_expr, GRB.MINIMIZE)
        
        # ---------------------- Routing Constraints ----------------------
        # 1. Each truck must start at depot 0 exactly once.
        for k in self.trucks:
            expr = gp.LinExpr()
            for j in self.nodes:
                if j == self.depot:
                    continue
                expr.addTerms(1, self.x_vars[(self.depot, j, k)])
            self.model.addConstr(expr == 1, name=f"truck_start_{k}")
        
        # 2. Each truck must end at the duplicate depot exactly once.
        for k in self.trucks:
            expr = gp.LinExpr()
            for i in self.nodes:
                if i == self.dup_depot:
                    continue
                expr.addTerms(1, self.x_vars[(i, self.dup_depot, k)])
            self.model.addConstr(expr == 1, name=f"truck_end_{k}")
        
        # 3. Flow conservation for trucks: For each truck and each customer, inflow equals outflow.
        for k in self.trucks:
            for j in self.customers:
                expr_in = gp.LinExpr()
                expr_out = gp.LinExpr()
                for i in self.nodes:
                    if i == j:
                        continue
                    expr_in.addTerms(1, self.x_vars[(i, j, k)])
                    expr_out.addTerms(1, self.x_vars[(j, i, k)])
                self.model.addConstr(expr_in == expr_out, name=f"truck_flow_{j}_{k}")
        
        # 4. Flow conservation for drones: For each drone and each customer, inflow equals outflow.
        for d in self.drones:
            for j in self.customers:
                expr_in = gp.LinExpr()
                expr_out = gp.LinExpr()
                for i in self.nodes:
                    if i == j:
                        continue
                    expr_in.addTerms(1, self.y_vars[(i, j, d)])
                    expr_out.addTerms(1, self.y_vars[(j, i, d)])
                self.model.addConstr(expr_in == expr_out, name=f"drone_flow_{j}_{d}")
        
        # 5. Each customer is visited exactly once (either by truck or by drone).
        for j in self.customers:
            expr = gp.LinExpr()
            for i in self.nodes:
                if i == j:
                    continue
                for k in self.trucks:
                    expr.addTerms(1, self.x_vars[(i, j, k)])
                for d in self.drones:
                    expr.addTerms(1, self.y_vars[(i, j, d)])
            self.model.addConstr(expr == 1, name=f"visit_once_{j}")
        
        # 6. Linking constraints: z[i,j,k,d] <= x[i,j,k]
        for i in self.nodes:
            for j in self.nodes:
                if i == j:
                    continue
                for k in self.trucks:
                    for d in self.drones:
                        self.model.addConstr(self.z_vars[(i, j, k, d)] <= self.x_vars[(i, j, k)],
                                               name=f"link_z_{i}_{j}_{k}_{d}")
        
        # ---------------------- Timing Constraints ----------------------
        # Truck timing: aT[j,k] >= aT[i,k] + t_T[i,j] - (1 - x[i,j,k])*big_M for all arcs.
        for k in self.trucks:
            for i in self.nodes:
                for j in self.nodes:
                    if i == j:
                        continue
                    self.model.addConstr(
                        self.aT_vars[(j, k)] >= self.aT_vars[(i, k)] + self.t_T[i, j] - (1 - self.x_vars[(i, j, k)]) * self.big_M,
                        name=f"truck_time_{i}_{j}_{k}"
                    )
        # Drone timing: aD[j,d] >= aD[i,d] + t_D[i,j] - (1 - y[i,j,d])*big_M for all arcs.
        for d in self.drones:
            for i in self.nodes:
                for j in self.nodes:
                    if i == j:
                        continue
                    self.model.addConstr(
                        self.aD_vars[(j, d)] >= self.aD_vars[(i, d)] + self.t_D[i, j] - (1 - self.y_vars[(i, j, d)]) * self.big_M,
                        name=f"drone_time_{i}_{j}_{d}"
                    )
        # Maximum working hours for trucks and drones.
        for k in self.trucks:
            for j in self.nodes:
                self.model.addConstr(self.aT_vars[(j, k)] <= self.L, name=f"truck_max_time_{j}_{k}")
        for d in self.drones:
            for j in self.nodes:
                self.model.addConstr(self.aD_vars[(j, d)] <= self.L, name=f"drone_max_time_{j}_{d}")
        
        # ---------------------- Endurance Constraints for Drones ----------------------
        # For each drone and arc (i,j): update cumulative flight time.
        for d in self.drones:
            for i in self.nodes:
                for j in self.nodes:
                    if i == j:
                        continue
                    # Update b_minus at node j based on b_plus at node i and travel time:
                    self.model.addConstr(
                        self.b_minus_vars[(j, d)] >= self.b_plus_vars[(i, d)] + self.t_D[i, j] - (1 - self.y_vars[(i, j, d)]) * self.big_M,
                        name=f"drone_endur_update_{i}_{j}_{d}"
                    )
            # Ensure that the cumulative flight time does not exceed drone endurance.
            for j in self.nodes:
                self.model.addConstr(
                    self.b_minus_vars[(j, d)] <= self.drone_endurance,
                    name=f"drone_endur_limit_{j}_{d}"
                )
        
        # ---------------------- Loading Constraints ----------------------
        # For simplicity, enforce that at each node, truck load (sum of delivery + pickup) does not exceed capacity.
        for k in self.trucks:
            for i in self.nodes:
                self.model.addConstr(self.F_vars[(i, k)] + self.G_vars[(i, k)] <= self.Q_T,
                                     name=f"truck_capacity_{i}_{k}")
        # For drones, enforce sum of loads does not exceed drone capacity.
        for d in self.drones:
            for i in self.nodes:
                self.model.addConstr(self.f_vars[(i, d)] + self.g_vars[(i, d)] <= self.Q_D,
                                     name=f"drone_capacity_{i}_{d}")
        # (Note: Detailed load update constraints as in the paper are complex; here we include basic capacity constraints.)

        self.model.update()
    
    def solve(self) -> Dict[str, Any]:
        """
        Solves the MILP model with Gurobi and extracts the solution.
        
        Returns:
            A dictionary representing the solution with routes, timing, and cost information.
        """
        self.model.optimize()
        solution = {}
        if self.model.status == GRB.OPTIMAL or self.model.status == GRB.TIME_LIMIT:
            # Extract truck routes for each truck.
            truck_routes = {k: [] for k in self.trucks}
            # For simplicity, reconstruct routes by starting at depot and following arcs with x=1.
            for k in self.trucks:
                current_node = self.depot
                route = [current_node]
                while current_node != self.dup_depot:
                    found = False
                    for j in self.nodes:
                        if current_node == j:
                            continue
                        var = self.x_vars.get((current_node, j, k))
                        if var is not None and var.X > 0.5:
                            route.append(j)
                            current_node = j
                            found = True
                            break
                    if not found:
                        # Infeasible to continue route reconstruction.
                        break
                truck_routes[k] = route
            solution["truck_routes"] = truck_routes
            
            # Extract drone routes similarly.
            drone_routes = {d: [] for d in self.drones}
            for d in self.drones:
                current_node = self.depot
                route = [current_node]
                while current_node != self.dup_depot:
                    found = False
                    for j in self.nodes:
                        if current_node == j:
                            continue
                        var = self.y_vars.get((current_node, j, d))
                        if var is not None and var.X > 0.5:
                            route.append(j)
                            current_node = j
                            found = True
                            break
                    if not found:
                        break
                drone_routes[d] = route
            solution["drone_routes"] = drone_routes
            
            # Compute objective cost.
            solution["objective"] = self.model.objVal
            
            # (Additional timing, load, and synchronization details can be extracted similarly if needed.)
        else:
            print("No feasible solution found.")
        return solution


# ------------------------- ALNSModel Class -------------------------
class ALNSModel:
    """ALNSModel implements the Adaptive Large Neighborhood Search metaheuristic for MFS©\VRPD."""
    
    def __init__(self, instance: Any, config: Any) -> None:
        """
        Initialize ALNS model with instance data and configuration.
        
        Args:
            instance: Generated instance data from DatasetLoader.
            config: Configuration object from config.py.
        """
        self.instance = instance
        self.config = config
        
        # Determine fleet sizes based on instance type.
        instance_type = self.instance.instance_type.lower()
        if instance_type == "small":
            self.num_trucks = 2
            self.num_drones = 2
        elif instance_type == "medium":
            self.num_trucks = 3
            self.num_drones = 2
        elif instance_type == "large":
            self.num_trucks = 4
            self.num_drones = 2
        else:
            self.num_trucks = 2
            self.num_drones = 2
        
        # Set basic parameters.
        self.Q_T: float = float(self.config.fleet.truck.capacity)
        self.Q_D: float = float(self.config.fleet.drone.capacity)
        self.L: float = float(self.config.working_hours)
        self.truck_cost: float = float(self.config.cost_parameters.truck_cost)
        self.drone_cost: float = float(self.config.cost_parameters.drone_cost)
        self.truck_dist = self.instance.distance_matrix_truck
        self.drone_dist = self.instance.distance_matrix_drone
        
        # Initialize adaptive operator weights for destroy and repair operators.
        self.destroy_weights: Dict[str, float] = {"shaw": 1.0, "worst": 1.0, "random": 1.0}
        self.repair_weights: Dict[str, float] = {"equal_priority": 1.0, "drone_first": 1.0, "truck_first": 1.0}
        
        # ALNS parameters from configuration.
        self.sigma1: int = self.config.alns_parameters.adaptive_selection.sigma1
        self.sigma2: int = self.config.alns_parameters.adaptive_selection.sigma2
        self.sigma3: int = self.config.alns_parameters.adaptive_selection.sigma3
        self.sigma4: int = self.config.alns_parameters.adaptive_selection.sigma4
        self.reaction_index: float = self.config.alns_parameters.adaptive_selection.reaction_index
        
        # Initialize solution placeholder.
        self.current_solution: Dict[str, Any] = {}
    
    def initialize_solution(self) -> Dict[str, Any]:
        """
        Generate an initial feasible solution using a two-phase heuristic:
          Phase 1: Construct a VRP solution via a nearest neighbor method.
          Phase 2: Convert the VRP solution to an MFS-VRPD solution by assigning drone subroutes.
        
        Returns:
            A solution object represented as a dictionary with keys:
              - "truck_routes": List of routes for trucks.
              - "drone_subroutes": List of drone subroute dicts, each with keys "launch", "visited", "docking".
              - "removed_customers": List (initially empty) to hold customers removed during destruction.
              - "cost": Total transportation cost.
        """
        # Phase 1: Nearest Neighbor VRP construction.
        unvisited = set(range(1, self.instance.num_customers + 1))  # customer indices
        truck_routes: List[List[int]] = []
        Q_T = self.Q_T
        L = self.L  # working time limit in hours
        
        # For each truck, create a route until all customers are visited.
        for t in range(self.num_trucks):
            route = [0]  # start at depot (index 0)
            current_node = 0
            current_load = 0.0
            current_time = 0.0
            # Continue until no unvisited customer can be feasibly inserted.
            while unvisited:
                best_candidate = None
                best_distance = float("inf")
                for j in unvisited:
                    # Check capacity feasibility: approximate by summing delivery and pickup.
                    demand = self.instance.demands[j]["delivery"] + self.instance.demands[j]["pickup"]
                    if current_load + demand > Q_T:
                        continue
                    travel_time = self.instance.time_matrix_truck[current_node, j]
                    time_to_depot = self.instance.time_matrix_truck[j, self.instance.num_nodes - 1]
                    if (current_time + travel_time + time_to_depot) > L:
                        continue
                    distance = self.truck_dist[current_node, j]
                    if distance < best_distance:
                        best_distance = distance
                        best_candidate = j
                if best_candidate is None:
                    break
                # Add the best candidate to the route.
                route.append(best_candidate)
                current_load += self.instance.demands[best_candidate]["delivery"] + self.instance.demands[best_candidate]["pickup"]
                current_time += self.instance.time_matrix_truck[current_node, best_candidate]
                current_node = best_candidate
                unvisited.remove(best_candidate)
            # End route at duplicate depot.
            route.append(self.instance.num_nodes - 1)
            truck_routes.append(route)
            # If all customers visited, break out.
            if not unvisited:
                break
        # If there are still unvisited customers, assign them arbitrarily to new routes.
        while unvisited:
            route = [0]
            current_node = 0
            for j in list(unvisited):
                route.append(j)
                unvisited.remove(j)
            route.append(self.instance.num_nodes - 1)
            truck_routes.append(route)
        
        # Phase 2: Conversion to MFS-VRPD solution.
        # For a simple heuristic, for each truck route, if a customer is drone eligible and
        # if serving it via drone is feasible (drone endurance constraint), remove it from the truck route
        # and assign a drone subroute.
        drone_subroutes: List[Dict[str, Any]] = []
        for route in truck_routes:
            # We'll process a copy of the route (excluding depots)
            new_route = [route[0]]
            i = 1
            while i < len(route) - 1:
                customer = route[i]
                is_drone_eligible = self.instance.demands[customer]["drone_eligible"]
                if is_drone_eligible:
                    # Check if drone can serve this customer:
                    launch = new_route[-1]
                    docking = route[i + 1]
                    # Compute estimated drone flight time (in hours).
                    flight_time = (self.instance.time_matrix_drone[launch, customer] +
                                   self.instance.time_matrix_drone[customer, docking])
                    if flight_time <= (self.config.fleet.drone.endurance / 60.0):
                        # Assign this customer to a drone subroute.
                        drone_subroutes.append({
                            "launch": launch,
                            "visited": [customer],
                            "docking": docking
                        })
                        # Instead of adding customer into truck route, skip it.
                        new_route.append(docking)
                        i += 2
                        continue
                # Otherwise, keep the customer in truck route.
                new_route.append(customer)
                i += 1
            # Ensure the route ends with the duplicate depot.
            if new_route[-1] != route[-1]:
                new_route.append(route[-1])
            # Replace the truck route with the new one.
            route[:] = new_route
        
        # Construct the initial solution dictionary.
        solution = {
            "truck_routes": truck_routes,         # List of lists of node indices.
            "drone_subroutes": drone_subroutes,     # List of dicts with keys "launch", "visited", "docking".
            "removed_customers": [],                # Initially empty.
            "cost": self.compute_cost({"truck_routes": truck_routes, "drone_subroutes": drone_subroutes})
        }
        self.current_solution = solution
        return solution
    
    def optimize(self) -> Dict[str, Any]:
        """
        Run the ALNS metaheuristic optimization loop.
        
        Returns:
            The best solution found (as a dictionary).
        """
        # Initialize solution.
        s_current = self.initialize_solution()
        s_best = copy.deepcopy(s_current)
        best_cost = s_best["cost"]
        
        # Determine number of iterations based on instance type.
        instance_type = self.instance.instance_type.lower()
        if instance_type == "small":
            niters = self.config.training.niters_small
        else:
            niters = self.config.training.niters_large
        
        # Initial temperature from configuration.
        T = float(self.config.training.initial_temperature)
        cooling_rate = float(self.config.training.cooling_rate)
        max_non_improve = int(self.config.training.max_non_improve)
        non_improve_count = 0
        
        for iter in range(niters):
            # Select and apply a destroy operator.
            s_destroyed, used_destroy_operator = self.apply_destroy_operator(s_current)
            # Then apply a repair operator.
            s_repaired, used_repair_operator = self.apply_repair_operator(s_destroyed)
            
            # Check feasibility of s_repaired.
            if not self.check_solution_feasible(s_repaired):
                continue  # Skip this iteration if infeasible.
            
            new_cost = self.compute_cost(s_repaired)
            old_cost = self.compute_cost(s_current)
            
            # Simulated annealing acceptance.
            if new_cost < old_cost:
                accept = True
                sigma = self.sigma1 if new_cost < best_cost else self.sigma2
            else:
                # Compute acceptance probability (using exp((old_cost - new_cost)/T)).
                prob = math.exp((old_cost - new_cost) / T)
                accept = (random.random() < prob)
                sigma = self.sigma3 if accept else self.sigma4
            
            if accept:
                s_current = s_repaired
                if new_cost < best_cost:
                    s_best = copy.deepcopy(s_repaired)
                    best_cost = new_cost
                    non_improve_count = 0
                else:
                    non_improve_count += 1
            else:
                non_improve_count += 1
            
            # Update operator weights based on performance.
            self.update_operator_weights(used_destroy_operator, used_repair_operator, sigma)
            
            # Update temperature.
            T *= cooling_rate
            
            # Optional: Print iteration info for logging.
            # print(f"Iteration {iter}, current cost: {self.compute_cost(s_current):.2f}, best cost: {best_cost:.2f}, T: {T:.4f}")
            
            if non_improve_count >= max_non_improve:
                break
        
        return s_best
    
    def apply_destroy_operator(self, solution: Dict[str, Any]) -> Tuple[Dict[str, Any], str]:
        """
        Apply a destroy operator to remove a subset of customers.
        Three operators are available: "shaw", "worst", and "random".
        Selection is made probabilistically based on adaptive weights.
        
        Args:
            solution: The current solution dictionary.
            
        Returns:
            A tuple (new_solution, operator_used) where new_solution is the partially
            destroyed solution and operator_used is the name of the operator applied.
        """
        # Choose an operator based on weights.
        operators = list(self.destroy_weights.keys())
        weights = [self.destroy_weights[op] for op in operators]
        chosen_operator = random.choices(operators, weights=weights, k=1)[0]
        
        new_solution = copy.deepcopy(solution)
        # Initialize removed_customers list if not present.
        if "removed_customers" not in new_solution:
            new_solution["removed_customers"] = []
            
        if chosen_operator == "random":
            # Randomly remove one customer from one truck route.
            truck_routes = new_solution["truck_routes"]
            non_empty_routes = [route for route in truck_routes if len(route) > 2]  # exclude depot-only routes
            if non_empty_routes:
                route = random.choice(non_empty_routes)
                # Remove a random customer from the route (not depot and duplicate depot).
                candidate_indices = list(range(1, len(route) - 1))
                if candidate_indices:
                    idx_to_remove = random.choice(candidate_indices)
                    removed_customer = route.pop(idx_to_remove)
                    new_solution["removed_customers"].append(removed_customer)
            # For simplicity, do not modify drone subroutes here.
        
        elif chosen_operator == "shaw":
            # Remove a cluster based on similarity.
            # Pick a random customer as seed.
            all_customers = []
            for route in new_solution["truck_routes"]:
                all_customers.extend(route[1:-1])
            if all_customers:
                seed = random.choice(all_customers)
                # Compute similarity (Euclidean distance) from seed for each customer.
                coords = self.instance.coordinates
                seed_coord = coords[seed]
                similarities = {}
                for cust in all_customers:
                    dist = np.linalg.norm(coords[cust] - seed_coord)
                    similarities[cust] = dist
                # Remove customers with similarity below a threshold.
                threshold = np.percentile(list(similarities.values()), 50)
                for cust, sim in similarities.items():
                    if sim <= threshold and cust not in new_solution["removed_customers"]:
                        # Remove customer from truck routes.
                        for route in new_solution["truck_routes"]:
                            if cust in route[1:-1]:
                                route.remove(cust)
                        new_solution["removed_customers"].append(cust)
        elif chosen_operator == "worst":
            # Remove the customer with the highest attributable cost in truck routes.
            worst_customer = None
            worst_increase = -float("inf")
            for route in new_solution["truck_routes"]:
                # Consider each insertion cost for each customer in the route.
                for idx in range(1, len(route) - 1):
                    cust = route[idx]
                    prev_node = route[idx - 1]
                    next_node = route[idx + 1]
                    cost_increase = self.truck_cost * (self.truck_dist[prev_node, cust] +
                                                       self.truck_dist[cust, next_node] -
                                                       self.truck_dist[prev_node, next_node])
                    if cost_increase > worst_increase:
                        worst_increase = cost_increase
                        worst_customer = cust
            if worst_customer is not None:
                # Remove worst_customer from truck routes.
                for route in new_solution["truck_routes"]:
                    if worst_customer in route[1:-1]:
                        route.remove(worst_customer)
                new_solution["removed_customers"].append(worst_customer)
        return new_solution, chosen_operator
    
    def apply_repair_operator(self, solution: Dict[str, Any]) -> Tuple[Dict[str, Any], str]:
        """
        Apply a repair operator to reinsert all removed customers into the solution.
        Three strategies are available: "equal_priority", "drone_first", and "truck_first".
        Selection is made probabilistically based on adaptive weights.
        
        Args:
            solution: The partially destroyed solution.
            
        Returns:
            A tuple (repaired_solution, operator_used) where repaired_solution is the new feasible solution 
            and operator_used is the name of the repair operator applied.
        """
        operators = list(self.repair_weights.keys())
        weights = [self.repair_weights[op] for op in operators]
        chosen_operator = random.choices(operators, weights=weights, k=1)[0]
        
        new_solution = copy.deepcopy(solution)
        removed = new_solution.get("removed_customers", [])
        
        # For simplicity, we reinsert each removed customer into the truck route that minimizes the incremental cost.
        for customer in removed:
            best_increase = float("inf")
            best_route_idx = None
            best_insert_position = None
            
            for r_idx, route in enumerate(new_solution["truck_routes"]):
                # Evaluate insertion in every possible position (between depot and dup depot).
                for pos in range(1, len(route)):
                    prev_node = route[pos - 1]
                    next_node = route[pos]
                    increase = self.truck_cost * (self.truck_dist[prev_node, customer] +
                                                  self.truck_dist[customer, next_node] -
                                                  self.truck_dist[prev_node, next_node])
                    if increase < best_increase:
                        best_increase = increase
                        best_route_idx = r_idx
                        best_insert_position = pos
            if best_route_idx is not None and best_insert_position is not None:
                new_solution["truck_routes"][best_route_idx].insert(best_insert_position, customer)
        
        # Clear the removed_customers list after repair.
        new_solution["removed_customers"] = []
        
        # For simplicity, we do not use drone insertion in this basic repair if not chosen.
        # In more advanced repair operators, one could first try drone insertion if chosen_operator=="drone_first".
        return new_solution, chosen_operator
    
    def update_operator_weights(self, destroy_operator: str, repair_operator: str, sigma: int) -> None:
        """
        Update the adaptive operator weights for the chosen destroy and repair operators.
        The update formula is:
            new_weight = (1 - reaction_index) * current_weight + reaction_index * sigma
        
        Args:
            destroy_operator: The name of the destroy operator used.
            repair_operator: The name of the repair operator used.
            sigma: The reward value for the iteration (selected from sigma1, sigma2, sigma3, sigma4).
        """
        # Update destroy operator weight.
        current_weight = self.destroy_weights.get(destroy_operator, 1.0)
        new_weight = (1 - self.reaction_index) * current_weight + self.reaction_index * sigma
        self.destroy_weights[destroy_operator] = new_weight
        
        # Update repair operator weight.
        current_weight = self.repair_weights.get(repair_operator, 1.0)
        new_weight = (1 - self.reaction_index) * current_weight + self.reaction_index * sigma
        self.repair_weights[repair_operator] = new_weight
    
    def compute_cost(self, solution: Dict[str, Any]) -> float:
        """
        Compute the total transportation cost of the solution.
        
        The cost is computed as:
          - For each truck route: sum_{arc in route} (truck_cost * distance on truck layer)
          - For each drone subroute: for each subroute with launch, visited, and docking nodes,
            cost is computed as drone_cost * (distance from launch to first visited + distances between visited nodes + distance from last visited to docking).
        
        Args:
            solution: The solution dictionary.
            
        Returns:
            Total cost as a float.
        """
        total_cost = 0.0
        # Truck routes cost.
        for route in solution.get("truck_routes", []):
            for i in range(len(route) - 1):
                total_cost += self.truck_cost * self.truck_dist[route[i], route[i + 1]]
        # Drone subroutes cost.
        for sub in solution.get("drone_subroutes", []):
            launch = sub.get("launch")
            docking = sub.get("docking")
            visited = sub.get("visited", [])
            if visited:
                cost_route = self.drone_cost * (self.drone_dist[launch, visited[0]])
                for i in range(len(visited) - 1):
                    cost_route += self.drone_cost * self.drone_dist[visited[i], visited[i + 1]]
                cost_route += self.drone_cost * self.drone_dist[visited[-1], docking]
                total_cost += cost_route
        return total_cost
    
    def check_solution_feasible(self, solution: Dict[str, Any]) -> bool:
        """
        Check the feasibility of the solution.
        
        For simplicity, we verify that every customer appears exactly once
        in the union of truck routes and drone subroutes.
        
        Args:
            solution: The solution dictionary.
            
        Returns:
            True if feasible, False otherwise.
        """
        visited_customers = set()
        # Collect customers from truck routes (exclude depot 0 and duplicate depot).
        for route in solution.get("truck_routes", []):
            for node in route[1:-1]:
                visited_customers.add(node)
        # Collect customers from drone subroutes.
        for sub in solution.get("drone_subroutes", []):
            for node in sub.get("visited", []):
                visited_customers.add(node)
        required_customers = set(range(1, self.instance.num_customers + 1))
        return visited_customers == required_customers
