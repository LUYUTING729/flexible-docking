"""trainer.py
This module implements the Trainer class for the MFS©\VRPD project.
The Trainer coordinates the overall optimization procedure by managing 
the solution process (via MILPModel for small instances or ALNSModel for
medium/large instances), logging intermediate metrics, and reporting the final solution.

The Trainer class uses the configuration parameters (e.g., iteration limits, 
maximum non-improvement count, time limits, cooling rate) from config.py.
It is designed to be reused as part of the complete project.
"""

import time
import logging
from typing import Any, Dict

# Import the MILPModel and ALNSModel classes from model.py.
from model import MILPModel, ALNSModel


class Trainer:
    """Coordinates the optimization process for MFS©\VRPD.

    The Trainer class accepts a model (MILPModel or ALNSModel), instance data,
    and configuration settings. It invokes the appropriate optimization routine,
    logs intermediate and final results, and returns the final solution with
    performance metrics.
    """

    def __init__(self, model: Any, instance: Any, config: Any) -> None:
        """
        Initialize the Trainer object.

        Args:
            model (Any): An instance of MILPModel or ALNSModel.
            instance (Any): The problem instance data generated by DatasetLoader.
            config (Any): Configuration object imported from config.py.
        """
        self.model = model
        self.instance = instance
        self.config = config
        self.logs = []  # List to store iteration logs and metrics.

        # Set up basic logging.
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s"
        )
        logging.info("Trainer initialized with model of type: %s",
                     "MILPModel" if isinstance(self.model, MILPModel) else "ALNSModel")

    def train(self) -> Dict[str, Any]:
        """
        Execute the training/optimization process for the given model.

        For MILPModel, the trainer builds the model and calls solve(). 
        For ALNSModel, it invokes the iterative optimize() method.
        The method logs runtime and solution quality metrics.

        Returns:
            Dict[str, Any]: A dictionary representing the final solution,
            including routes, objective cost, runtime and other performance metrics.
        """
        start_time: float = time.time()
        logging.info("Begin training process...")

        try:
            # Check the type of the provided model and run the appropriate optimization.
            if isinstance(self.model, MILPModel):
                # MILPModel: Build the full model and solve using Gurobi.
                logging.info("Using MILPModel for optimization.")
                self.model.build_model()
                solution: Dict[str, Any] = self.model.solve()
            elif isinstance(self.model, ALNSModel):
                # ALNSModel: Run the iterative ALNS optimization.
                logging.info("Using ALNSModel for optimization.")
                solution = self.model.optimize()
            else:
                message: str = "Provided model must be an instance of MILPModel or ALNSModel."
                logging.error(message)
                raise ValueError(message)
        except Exception as e:
            logging.error("Error during optimization: %s", str(e))
            raise e

        end_time: float = time.time()
        runtime: float = end_time - start_time

        # Log the final results.
        logging.info("Training complete. Total runtime: %.2f seconds.", runtime)
        final_objective = solution.get("objective", solution.get("cost", None))
        if final_objective is not None:
            logging.info("Final Objective Cost: %.2f", final_objective)
        else:
            logging.warning("Final solution does not include an objective cost.")

        # Append final metrics to the logs.
        self.logs.append({
            "runtime": runtime,
            "final_objective": final_objective,
        })

        # Add runtime and model type information to the solution.
        solution["runtime"] = runtime
        solution["model_type"] = "MILP" if isinstance(self.model, MILPModel) else "ALNS"

        return solution


# For testing purposes: if this module is run directly, perform a simple training run.
if __name__ == "__main__":
    # This test block would normally be replaced by main.py in the full project.
    # Here, we simulate a scenario using dummy values if MILPModel or ALNSModel has been instantiated.
    try:
        # Import CONFIG from config.py if needed.
        from config import CONFIG
        # For a test, we assume that instance and model objects are already created.
        # In a real scenario, these would be obtained via DatasetLoader and appropriate model selection.
        # For demonstration, we simply log a message.
        logging.info("This is a test run of Trainer. Please run the full project via main.py.")
    except Exception as ex:
        logging.error("Error during Trainer test run: %s", str(ex))
